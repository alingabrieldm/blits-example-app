var E=Object.defineProperty;var p=(n,s,e)=>s in n?E(n,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[s]=e;var r=(n,s,e)=>(p(n,typeof s!="symbol"?s+"":s,e),e);const y={currentView:Symbol("currentView"),cursorTagStart:Symbol("cursorTagStart"),computedKeys:Symbol("computedKeys"),destroy:Symbol("destroy"),index:Symbol("index"),init:Symbol("init"),inputEvents:Symbol("inputEvents"),intervals:Symbol("intervals"),level:Symbol("level"),methodKeys:Symbol("methodKeys"),originalState:Symbol("originalState"),propKeys:Symbol("propKeys"),ready:Symbol("ready"),renderer:Symbol("renderer"),routes:Symbol("routes"),settings:Symbol("settings"),state:Symbol("state"),stateKeys:Symbol("stateKeys"),textnode:Symbol("textnode"),timeouts:Symbol("timeouts"),type:Symbol("type"),watchers:Symbol("watchers"),watchKeys:Symbol("watchKeys"),wrapper:Symbol("wrapper"),children:Symbol.for("children"),components:Symbol.for("components"),isSlot:Symbol.for("isSlot"),props:Symbol.for("props"),slots:Symbol.for("slots"),componentType:Symbol.for("componentType")};class _{constructor(){r(this,"eventListeners",{})}on(s,e){let t=this.eventListeners[s];t||(t=[]),t.push(e),this.eventListeners[s]=t}off(s,e){const t=this.eventListeners[s];if(!t)return;if(!e){delete this.eventListeners[s];return}const i=t.indexOf(e);i>=0&&t.splice(i,1)}once(s,e){const t=(i,a)=>{this.off(s,t),e(i,a)};this.on(s,t)}emit(s,e){const t=this.eventListeners[s];t&&[...t].forEach(i=>{i(this,e)})}removeAllListeners(){this.eventListeners={}}}class T extends _{constructor(e,t){super();r(this,"fontFamily");r(this,"descriptors");r(this,"loaded",!1);this.fontFamily=e,this.descriptors={style:"normal",weight:"normal",stretch:"normal",...t}}static convertToCssFontFaceDescriptors(e){return{style:e.style,weight:typeof e.weight=="number"?`${e.weight}`:e.weight,stretch:e.stretch,unicodeRange:e.unicodeRange,variant:e.variant,featureSettings:e.featureSettings,display:e.display}}}const S={LINE_FEED:10,CARRIAGE_RETURN:13,SPACE:32,TAB:9,ZERO_WIDTH_SPACE:8203,ZERO_WIDTH_NON_JOINER:8204,ZERO_WIDTH_JOINER:8205,LEFT_TO_RIGHT_MARK:8206,RIGHT_TO_LEFT_MARK:8207,LEFT_TO_RIGHT_EMBEDDING:8234,RIGHT_TO_LEFT_EMBEDDING:8235,POP_DIRECTIONAL_FORMATTING:8236,LEFT_TO_RIGHT_OVERRIDE:8237,RIGHT_TO_LEFT_OVERRIDE:8238,LINE_SEPARATOR:8232,PARAGRAPH_SEPARATOR:8233,OBJECT_REPLACEMENT_CHARACTER:65532,REPLACEMENT_CHARACTER:65533,ZERO_WIDTH_NO_BREAK_SPACE:65279,LEFT_TO_RIGHT_ISOLATE:8294,RIGHT_TO_LEFT_ISOLATE:8295,FIRST_STRONG_ISOLATE:8296,POP_DIRECTIONAL_ISOLATE:8297,INHIBIT_SYMMETRIC_SWAPPING:8298,ACTIVATE_SYMMETRIC_SWAPPING:8299,INHIBIT_ARABIC_FORM_SHAPING:8300,ACTIVATE_ARABIC_FORM_SHAPING:8301,NATIONAL_DIGIT_SHAPES:8302,NOMINAL_DIGIT_SHAPES:8303,LEFT_TO_RIGHT_BOUNDARY:8206,RIGHT_TO_LEFT_BOUNDARY:8207};class u{}class x extends u{constructor(e,t){super();r(this,"data");r(this,"glyphMap");r(this,"kernings");this.data=e,this.glyphMap=t;const i=this.kernings={};e.kernings.forEach(a=>{const o=a.second,h=i[o]=i[o]||{};h[a.first]=a.amount}),this.kernings=i}*shapeText(e,t){var o;let i,a;for(;(i=t.peek())&&!i.done;){const h=i.value,l=this.glyphMap.get(h);if(t.next(),l!==void 0){const c=a!==void 0?(((o=this.kernings[l.id])==null?void 0:o[a])||0)+e.letterSpacing:0;a=l.id,yield{mapped:!0,glyphId:l.id,codepoint:h,cluster:t.lastIndex,xAdvance:l.xadvance+c,yAdvance:0,xOffset:l.xoffset+c,yOffset:l.yoffset,xBearing:0,yBearing:0,width:l.width,height:l.height}}else h===S.LINE_FEED&&(a=void 0),yield{mapped:!1,codepoint:h,cluster:t.lastIndex}}}}class I extends T{constructor(e,t,i,a,o,h){super(e,t);r(this,"type");r(this,"texture");r(this,"maxCharHeight",0);r(this,"data");r(this,"shaper");r(this,"glyphMap",new Map);this.type=i,a.renderer,this.texture=a.txManager.loadTexture("ImageTexture",{src:o,premultiplyAlpha:!1},{preload:!0}),this.texture.on("loaded",()=>{this.checkLoaded()}),fetch(h).then(async l=>{this.data=await l.json();let c=0;this.data.chars.forEach(d=>{this.glyphMap.set(d.id,d);const f=d.yoffset+d.height;f>c&&(c=f)}),this.maxCharHeight=c,this.shaper=new x(this.data,this.glyphMap),this.checkLoaded()}).catch(console.error)}getAtlasEntry(e){const t=this.glyphMap.get(e);if(t===void 0)throw new Error(`Glyph ${e} not found in font ${this.fontFamily}`);return{x:t.x,y:t.y,width:t.width,height:t.height}}checkLoaded(){this.loaded||this.texture.state==="loaded"&&this.data&&(this.loaded=!0,this.emit("loaded"))}}class g extends T{constructor(e,t,i){super(e,t);r(this,"fontFace");r(this,"fontUrl");const a=i.replace(/\(|\)/g,""),o=this.descriptors,h={style:o.style,weight:typeof o.weight=="number"?`${o.weight}`:o.weight,stretch:o.stretch,unicodeRange:o.unicodeRange,variant:o.variant,featureSettings:o.featureSettings,display:o.display},l=new FontFace(e,`url(${a})`,h);l.load().then(()=>{this.loaded=!0,this.emit("loaded")}).catch(console.error),this.fontFace=l,this.fontUrl=i}}class R{}const A={[y.settings]:{},get(n,s=null){return n in this[y.settings]?this[y.settings][n]:s},set(n,s){typeof n=="object"?Object.keys(n).forEach(e=>{this.set(e,n[e])}):this[y.settings][n]=s}};export{R as C,_ as E,I as S,g as W,A as a,y as s};
